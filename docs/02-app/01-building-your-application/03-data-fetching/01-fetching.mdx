---
title: Data Fetching, Caching, and Revalidating
nav_title: Fetching, Caching, and Revalidating
description: Learn how to fetch, cache, and revalidate data in your Next.js application.
---

Data fetching is a core part of any application. This page goes through how you can fetch, cache, and revalidate data. It also covers recommended patterns for fetching data with React.

## Fetching Data on the Server

Next.js extends the native [`fetch` Web API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) to allow you to:

- Configure the [caching](#caching-data) and [revalidating](#revalidating-data) behavior for each fetch request.
- Automatically [memoize](#fetching-data-where-its-needed-memoization) fetch requests while rendering a React Component tree.

You can use `fetch` with [`async`/`await` in Server Components](https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises), [Route Handlers](), and [Server Actions]().

For example:

```tsx filename="app/page.tsx" switcher
async function getData() {
  const res = await fetch('https://api.example.com/...')
  // The return value is *not* serialized
  // You can return Date, Map, Set, etc.

  if (!res.ok) {
    // This will activate the closest `error.js` Error Boundary
    throw new Error('Failed to fetch data')
  }

  return res.json()
}

export default async function Page() {
  const data = await getData()

  return <main></main>
}
```

```jsx filename="app/page.js" switcher
async function getData() {
  const res = await fetch('https://api.example.com/...')
  // The return value is *not* serialized
  // You can return Date, Map, Set, etc.

  if (!res.ok) {
    // This will activate the closest `error.js` Error Boundary
    throw new Error('Failed to fetch data')
  }

  return res.json()
}

export default async function Page() {
  const data = await getData()

  return <main></main>
}
```

> **Good to know**:
>
> To use `async`/`await` in a Server Component with TypeScript, you'll need to use TypeScript `5.1.3` or higher and `@types/react` `18.2.8` or higher.
> Next.js provides helpful functions you may need when fetching data in Server Components such as [`cookies`](/docs/app/api-reference/functions/cookies) and [`headers`](/docs/app/api-reference/functions/headers). These will cause the route to be dynamically rendered as they rely on runtime information.

### Caching Data

Caching is the process of storing data on the server (e.g. an [Edge Network](https://vercel.com/docs/concepts/edge-network/overview)) so it doesn't need to be re-fetched from your data source on each request.

By default, Next.js automatically caches the returned values of `fetch` in the [Data Cache](/docs/app/building-your-application/data-fetching/caching#data-cache) on the server. This means that the data can be fetched at build time or runtime, cached, and reused on each request.

```js
fetch('https://...') // cache: 'force-cache' is the default, and can be omitted
```

> **How does the Data Cache work?**
>
> The Data Cache is a persistent [HTTP cache](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching). Depending on your platform, the cache can scale automatically and be shared across multiple regions.
>
> Next.js extends the [options object](https://developer.mozilla.org/en-US/docs/Web/API/fetch#:~:text=preflight%20requests.-,cache,-A%20string%20indicating) of the `fetch` function to allow each request on the server to set its own persistent caching behavior.
> During rendering, when Next.js comes across a fetch, it will check the cache to see if the data is already available. If it is, it will return the cached data. If not, it will fetch and store data for future requests.
>
> Learn more about the [Data Cache](/docs/app/building-your-application/data-fetching/caching#data-cache).

### Revalidating Data

Revalidation is the process of purging the Data Cache and re-fetching the latest data. This is useful when your data changes and you want to ensure you show the latest information.

Cached data can be revalidated in two ways:

- **Time-based revalidation**: Automatically revalidate data after a certain amount of time has passed. This is useful for data that changes infrequently and freshness is not as critical. Time-based revalidation can be configured with the [Route Segment Config options](#segment-config-options) or per individual [`fetch` request](#fetchoptionsnextrevalidate).
- **On-demand revalidation**: Manually revalidate data based on an event (e.g. form submission). On-demand revalidation can use a tag-based or path-based approach to revalidate groups of data at once. This is useful for when you want to ensure the latest data is shown as soon as possible, or content from your headless CMS is updated. On-demand revalidation can be triggered with [`revalidateTag`](#fetchoptionsnexttag-and-revalidatetag) or [`revalidatePath`](#revalidatepath).

#### Time-based Revalidation

To revalidate data at a timed interval, you can use the `next.revalidate` option of `fetch` to set the cache lifetime of a resource (in seconds).

```js
fetch('https://...', { next: { revalidate: 3600 } })
```

Alternatively, to revalidate all `fetch` requests in a route segment, you can use the [Segment Config Options](#segment-config-options).

```jsx filename="layout.js / page.js"
export const revalidate = 3600 // revalidate every hour
```

If you have multiple fetch requests in a route, and each has a different revalidation frequency. The lowest time will be used for all requests.

> **How does time-based revalidation work?**
>
> If you set a `revalidate` time of `60`, all visitors will see the same data for one minute.
>
> 1. The first time a fetch request with `revalidate` is called, the data will be fetched from the external data source and stored in the Data Cache.
> 2. Any requests that are called within the 60-second window will return the cached data.
> 3. After the 60-second window, the next request will still return the cached (now stale) data.
> 4. Next.js will trigger a revalidation of the data in the background.
> 5. Once the data is fetched successfully, Next.js will update the Data Cache with the fresh data. If the background revalidation fails, the previous data will be kept unaltered.

#### On-demand Revalidation

Data can be revalidated on-demand by path ([`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)) or by cache tag ([`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)).

Next.js has a cache tagging system for invalidating `fetch` requests across routes.

1. When using `fetch`, you have the option to tag cache entries with one or more tags.
2. Then, you can call `revalidateTag` to revalidate all entries associated with that tag.

For example, the following `fetch` requests adds the cache tag `collection`:

```tsx filename="app/page.tsx" switcher
export default async function Page() {
  const res = await fetch('https://...', { next: { tags: ['collection'] } })
  const data = await res.json()
  // ...
}
```

```jsx filename="app/page.js" switcher
export default async function Page() {
  const res = await fetch('https://...', { next: { tags: ['collection'] } })
  const data = await res.json()
  // ...
}
```

The data can then be revalidated on-demand by calling `revalidateTag` in a [Route Handler](/docs/app/building-your-application/routing/router-handlers) or [Server Action]().

```ts filename="app/api/revalidate/route.ts" switcher
import { NextRequest, NextResponse } from 'next/server'
import { revalidateTag } from 'next/cache'

export async function GET(request: NextRequest) {
  const tag = request.nextUrl.searchParams.get('tag')
  revalidateTag(tag)
  return NextResponse.json({ revalidated: true, now: Date.now() })
}
```

```js filename="app/api/revalidate/route.js" switcher
import { NextResponse } from 'next/server'
import { revalidateTag } from 'next/cache'

export async function GET(request) {
  const tag = request.nextUrl.searchParams.get('tag')
  revalidateTag(tag)
  return NextResponse.json({ revalidated: true, now: Date.now() })
}
```

Alternatively, you can use [`revalidatePath`](/docs/app/api-reference/functions/revalidatePath) in a [Route Handler]() or [Server Action]() to revalidate all data associated with a path.

See the [revalidateTag](/docs/app/api-reference/functions/revalidateTag) and [revalidatePath](/docs/app/api-reference/functions/revalidatePath) API references for more information.

#### Error handling and revalidation

If an error is thrown while attempting to revalidate data, the last successfully generated data will continue to be served from the cache. On the next subsequent request, Next.js will retry revalidating the data.

### Opting out of Data Caching

#### Individiual `fetch` Requests

To opt individual `fetch` requests out of caching, you can set the `cache` option in `fetch` to `'no-store'`. This will fetch data dynamically, on every request.

```js
fetch('https://...', { cache: 'no-store' })
```

View all the available `cache` options in the [`fetch` API reference](/docs/app/api-reference/functions/fetch).

> Requests are also **not** cached if:
>
> - The `fetch` request uses the `POST` method, the `Authorization` header, or `cookie` headers.
> - The `fetch` request is inside a Router Handler that uses the `POST` method.
> - `revalidate: 0` is configured on individual `fetch` requests
> - The `fetchCache` route segment option is configured to skip cache by default.

#### Multiple `fetch` Requests

If you have multiple `fetch` requests in a route segment (e.g. a layout or page), you can configure the caching behavior of all data requests in the segment using the [Segment Config Options]().

For example, using `const dynamic = 'force-dynamic` will cause all data to be fetched at request time, and the segment to be rendered dynamically.

```ts
// Add
export const dynamic = 'auto'
```

There's an extensive list of Segment Config options, giving you fine-grained control of static and dynamic behavior of a route segment. See the [API reference](/docs/app/api-reference/file-conventions/route-segment-config) for more.

## Fetching Data on the Client

If you need to fetch data on the client, we recommend using a third-party library such as [SWR](https://swr.vercel.app/) or [React Query](https://tanstack.com/query/v4). These libraries provide their own APIs for memoizing requests, caching, revalidating, and mutating data.

> **Future APIs**:
>
> `use` is a React function that **accepts and handles a promise** returned by a function. Wrapping `fetch` in `use` is currently **not** recommended in Client Components and may trigger multiple re-renders. Learn more about `use` in the [React RFC](https://github.com/acdlite/rfcs/blob/first-class-promises/text/0000-first-class-support-for-promises.md#usepromise).

## Fetching data with third-party libraries

In cases where you're using a third-party library that doesn't support or expose `fetch` (for example, a database, CMS, or ORM client), you can configure the caching and revalidating behavior of those requests using the [Route Segment Config Option]() and React's `cache` function.

Whether the data is cached or not will depend on whether the route segment is [statically or dynamically rendered](). If the segment is static (default), the output of the request will be cached and revalidated as part of the route segment. If the segment is dynamic, the output of the request will _not_ be cached and will be re-fetched on every request when the segment is rendered.

> **Good to know:**
>
> In the future, Next.js will have a API for configuring the caching and revalidating behavior of individual third-party requests. Learn more: [`unstable_cache`]()

### Example

In the example below:

- The `revalidate` option is set to `3600`, meaning the data will be cached and revalidated every hour.
- The React `cache` function is used to [memoize]() data requests.

```ts filename="utils/getUser.ts" switcher
import { cache } from 'react'

export const revalidate = 3600 // revalidate the data every hour

export const getUser = cache(async (id: string) => {
  const user = await db.user.findUnique({ id })
  return user
})
```

```js filename="utils/getUser.js" switcher
import { cache } from 'react'

export const revalidate = 3600 // revalidate the data every hour

export const getUser = cache(async (id) => {
  const user = await db.user.findUnique({ id })
  return user
})
```

Although the `getUser` function is called twice, only one query will be made to the database.

```tsx filename="app/user/[id]/layout.tsx" switcher
import { getUser } from '@utils/getUser'

export default async function UserLayout({
  params: { id },
}: {
  params: { id: string }
}) {
  const user = await getUser(id)
  // ...
}
```

```jsx filename="app/user/[id]/layout.js" switcher
import { getUser } from '@utils/getUser'

export default async function UserLayout({ params: { id } }) {
  const user = await getUser(id)
  // ...
}
```

```tsx filename="app/user/[id]/page.tsx" switcher
import { getUser } from '@utils/getUser'

export default async function Page({
  params: { id },
}: {
  params: { id: string }
}) {
  const user = await getUser(id)
  // ...
}
```

```jsx filename="app/user/[id]/page.js" switcher
import { getUser } from '@utils/getUser'

export default async function Page({ params: { id } }) {
  const user = await getUser(id)
  // ...
}
```

## Data Fetching Patterns

There are a few recommended patterns and best practises for fetching data in React and Next.js:

### Fetching Data on the Server

Whenever possible, we recommend fetching data in on the server with [React Server Components](/docs/getting-started/react-essentials#server-components). This allows you to:

- Have direct access to backend data resources (e.g. databases).
- Keep your application more secure by preventing sensitive information, such as access tokens and API keys, from being exposed to the client.
- Fetch data and render in the same environment. This reduces both the back-and-forth communication between client and server, as well as the work on the main thread on the client.
- Perform multiple data fetches with single round-trip instead of multiple individual requests on the client.
- Reduce client-server [waterfalls](#parallel-and-sequential-data-fetching).
- Depending on your region, data fetching can also happen closer to your data source, reducing latency and improving performance.

### Fetching Data Where It's Needed

If you need to use the same data (e.g. current user) in multiple components in a tree, you do not have to fetch data globally, nor pass data down as props. Instead, you can use `fetch` directly inside the component that needs it without worrying about the performance implications of making multiple requests for the same data.

This is possible because Next.js automatically memoizes `fetch` requests using React's `cache` function. Learn more about [request memoization](/docs/app/building-your-application/caching#react-cache)

> **Good to know**: This also applies to layouts, since it's not possible to pass data between a parent layout and its children.

### Parallel Data Fetching

To minimize client-server waterfalls, we recommend this pattern to fetch data in parallel:

```tsx filename="app/artist/[username]/page.tsx" switcher
import Albums from './albums'

async function getArtist(username: string) {
  const res = await fetch(`https://api.example.com/artist/${username}`)
  return res.json()
}

async function getArtistAlbums(username: string) {
  const res = await fetch(`https://api.example.com/artist/${username}/albums`)
  return res.json()
}

export default async function Page({
  params: { username },
}: {
  params: { username: string }
}) {
  // Initiate both requests in parallel
  const artistData = getArtist(username)
  const albumsData = getArtistAlbums(username)

  // Wait for the promises to resolve
  const [artist, albums] = await Promise.all([artistData, albumsData])

  return (
    <>
      <h1>{artist.name}</h1>
      <Albums list={albums}></Albums>
    </>
  )
}
```

```jsx filename="app/artist/[username]/page.js" switcher
import Albums from './albums'

async function getArtist(username) {
  const res = await fetch(`https://api.example.com/artist/${username}`)
  return res.json()
}

async function getArtistAlbums(username) {
  const res = await fetch(`https://api.example.com/artist/${username}/albums`)
  return res.json()
}

export default async function Page({ params: { username } }) {
  // Initiate both requests in parallel
  const artistData = getArtist(username)
  const albumsData = getArtistAlbums(username)

  // Wait for the promises to resolve
  const [artist, albums] = await Promise.all([artistData, albumsData])

  return (
    <>
      <h1>{artist.name}</h1>
      <Albums list={albums}></Albums>
    </>
  )
}
```

By starting the fetch prior to calling `await` in the Server Component, each request can eagerly start to fetch requests at the same time. This sets the components up so you can avoid waterfalls.

We can save time by initiating both requests in parallel, however, the user won't see the rendered result until both promises are resolved.

To improve the user experience, you can add a [suspense boundary](/docs/app/building-your-application/routing/loading-ui-and-streaming) to break up the rendering work and show part of the result as soon as possible:

```tsx filename="artist/[username]/page.tsx" switcher
import { getArtist, getArtistAlbums, type Album } from './api'

export default async function Page({
  params: { username },
}: {
  params: { username: string }
}) {
  // Initiate both requests in parallel
  const artistData = getArtist(username)
  const albumData = getArtistAlbums(username)

  // Wait for the artist's promise to resolve first
  const artist = await artistData

  return (
    <>
      <h1>{artist.name}</h1>
      {/* Send the artist information first,
          and wrap albums in a suspense boundary */}
      <Suspense fallback={<div>Loading...</div>}>
        <Albums promise={albumData} />
      </Suspense>
    </>
  )
}

// Albums Component
async function Albums({ promise }: { promise: Promise<Album[]> }) {
  // Wait for the albums promise to resolve
  const albums = await promise

  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>{album.name}</li>
      ))}
    </ul>
  )
}
```

```jsx filename="artist/[username]/page.js" switcher
import { getArtist, getArtistAlbums } from './api'

export default async function Page({ params: { username } }) {
  // Initiate both requests in parallel
  const artistData = getArtist(username)
  const albumData = getArtistAlbums(username)

  // Wait for the artist's promise to resolve first
  const artist = await artistData

  return (
    <>
      <h1>{artist.name}</h1>
      {/* Send the artist information first,
      and wrap albums in a suspense boundary */}
      <Suspense fallback={<div>Loading...</div>}>
        <Albums promise={albumData} />
      </Suspense>
    </>
  )
}

// Albums Component
async function Albums({ promise }) {
  // Wait for the albums promise to resolve
  const albums = await promise

  return (
    <ul>
      {albums.map((album) => (
        <li key={album.id}>{album.name}</li>
      ))}
    </ul>
  )
}
```

Take a look at the [preloading pattern](/docs/app/building-your-application/data-fetching/caching#preload-pattern-with-cache) for more information on improving components structure.

### Sequential Data Fetching

To fetch data sequentially, you can `fetch` directly inside the component that needs it, or you can `await` the result of `fetch` inside the component that needs it:

```tsx filename="app/artist/page.tsx" switcher
// ...

async function Playlists({ artistID }: { artistID: string }) {
  // Wait for the playlists
  const playlists = await getArtistPlaylists(artistID)

  return (
    <ul>
      {playlists.map((playlist) => (
        <li key={playlist.id}>{playlist.name}</li>
      ))}
    </ul>
  )
}

export default async function Page({
  params: { username },
}: {
  params: { username: string }
}) {
  // Wait for the artist
  const artist = await getArtist(username)

  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <Playlists artistID={artist.id} />
      </Suspense>
    </>
  )
}
```

```jsx filename="app/artist/page.js" switcher
// ...

async function Playlists({ artistID }) {
  // Wait for the playlists
  const playlists = await getArtistPlaylists(artistID)

  return (
    <ul>
      {playlists.map((playlist) => (
        <li key={playlist.id}>{playlist.name}</li>
      ))}
    </ul>
  )
}

export default async function Page({ params: { username } }) {
  // Wait for the artist
  const artist = await getArtist(username)

  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <Playlists artistID={artist.id} />
      </Suspense>
    </>
  )
}
```

By fetching data inside the component, each fetch request and nested segment in the route cannot start fetching data and rendering until the previous request or segment has completed.

### Blocking Rendering in a Route

By fetching data in a [layout](/docs/app/building-your-application/routing/pages-and-layouts), rendering for all route segments beneath it can only start once the data has finished loading.

In the `pages` directory, pages using server-rendering would show the browser loading spinner until `getServerSideProps` had finished, then render the React component for that page. This can be described as "all or nothing" data fetching. Either you had the entire data for your page, or none.

In the `app` directory, you have additional options to explore:

1. First, you can use `loading.js` to show an instant loading state from the server while streaming in the result from your data fetching function.
2. Second, you can move data fetching _lower_ in the component tree to only block rendering for the parts of the page that need it. For example, moving data fetching to a specific component rather than fetching it at the root layout.

Whenever possible, it's best to fetch data in the segment that uses it. This also allows you to show a loading state for only the part of the page that is loading, and not the entire page.
