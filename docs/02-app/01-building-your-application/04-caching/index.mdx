---
title: Caching in Next.js
nav_title: Caching
description: An overview of caching mechanisms in Next.js.
---

Next.js has a few caching mechanisms to improve your application's performance. This page provides an in-depth look at caching, the APIs you can use to configure them, and how they interact with each other.

## Overview

{/* TO DO: Diagram showing how caching mechanisms come into play in the request lifecycle, going from  initial request, to server, to response, to router cache, to subsequent navigation with new request. */}

Here's a high-level overview of the different caching mechanisms in Next.js and their purpose:

| Mechanism                     | What is cached?                | Where is it cached? | Why is it cached?                                             | Duration                        |
| ----------------------------- | ------------------------------ | ------------------- | ------------------------------------------------------------- | ------------------------------- |
| [React Cache](#react-cache)   | Return values of functions     | Server              | Reduce data store calls and share data between route segments | Per-request lifecycle           |
| [Data Cache](#data-cache)     | Return values of data requests | Server              | Store data across user requests and deployments               | Persistent (can be revalidated) |
| [Render Cache](#render-cache) | Rendered React Components      | Server              | Reduce rendering cost and improve performance                 | Persistent (can be revalidated) |
| [Router Cache](#router-cache) | Route Segments (RSC Payload)   | Client              | Reduce server requests and improve navigation experience      | User session or time-based.     |

## How caching works

### React Cache

React's `cache` function allows you to **memoize** the return value of a function, saving the result to memory. This means you can call the same function multiple times while only executing it once during a render pass.

In Next.js, the `fetch` API uses `cache` to **deduplicate** requests for the same data. Similar to memoization, request deduplication is an optimization that takes **multiple** requests for the same data and only makes a **single** request to the data source. This is done by storing the result of the first request in a temporary server-side cache, and returning the cached result for subsequent requests.

{/* Diagram */}

Since `fetch` requests are automatically deduplicated, you can fetch data in the components that need it without props drilling and worrying about the performance impact of making multiple requests for the same data. Deduplication applies to `fetch` requests in `generateMetadata`, `generateStaticParams`, Layouts, Pages, and other Server Components.

For cases where `fetch` is not suitable (e.g. database clients, CMS clients, or GraphQL), you can use React's `cache` function to manually deduplicate requests. Although Next.js uses `cache` to memoize data requests on the server, the `cache` function can also be used to memoize any function on the server or the client.

> **Memoization vs. Deduplication**:
>
> You may see the terms **memoization** and **deduplication** being used interchangeably. Memoization is a general term that applies storing the return values of **any function** in-memory, whereas request deduplication applies specifically to **data requests**.

#### Duration

The cache lasts the lifetime of a server request until the rendering pass completes.

#### Revalidating

Since the cache is cleared after each request, there is no need to revalidate the cache.

#### Opting out

There's no way to opt out of request deduplication for `fetch` requests.

### Data Cache

Next.js has a built-in Data Cache that stores the result of data requests across user requests and deployments.

By default, data requests that use `fetch` are automatically cached at build time. This is possible because Next.js extends the native `fetch` API to allow each request on the server to set its own persistent caching semantics.

You can use the [`cache`]() and [`next.revalidate`]() options of `fetch` to configure the caching behavior. In the browser, `cache` indicates how a fetch request will interact with the browser's HTTP cache, and with Next.js, the `cache` option also indicates how a server-side fetch request will interact with the framework's persistent HTTP cache.

When fetching data on the server, a `fetch` request first checks the persistent HTTP cache for a cached response. If a cached response is found, it is returned immediately. If not, the request is made to the data source, and the response is cached.

> **Static vs. Dynamic Data Fetching**:
>
> You may see the terms **Static Data Fetching** and **Dynamic Data Fetching** being used. Static Data Fetching refers to cached data requests (default), whereas Dynamic Data Fetching refers to data that is fetched on every request, at runtime.

#### Duration

The Data Cache is persistent across user requests and deployments unless you revalidate or opt-out.

#### Revalidating

Revalidation is the process of purging the Data Cache and re-fetching the latest data. This is useful when your data changes and you want to ensure you show the latest information.

Cached data can be revalidated in two ways:

- **Time-based revalidation**: Automatically revalidate data after a certain amount of time has passed. This is useful for data that changes infrequently and freshness is not as critical. Time-based revalidation can be configured with the [Route Segment Config options]() or per individual [`fetch` request]().
- **On-demand revalidation**: Manually revalidate data based on an event (e.g. form submission). On-demand revalidation can use a tag-based or path-based approach to revalidate groups of data at once. This is useful for when you want to ensure the latest data is always shown. On-demand revalidation can be configured with the [`revalidateTag`]() and [`revalidatePath`]() APIs.

> **Vercel Data Cache**
>
> If your Next.js application is deployed to Vercel, we recommend reading the [Vercel Data Cache](https://vercel.com/docs/infrastructure/data-cache) documentation for a better understanding of Vercel specific features.

#### Opting out

For individual data fetches, you can opt out of caching by setting the `cache` option to `no-store`. This means data will be fetched dynamically, on each request.

```jsx
// Opt out of caching
fetch(`https://...`, { cache: 'no-store' })
```

Alternatively, you can also use the [Route Segment Config options]() to opt out of caching for **all** data requests in a route segment.

### Render Cache

Next.js automatically caches the rendered result of React Components on the server at build time. This is an optimization that allows you to skip rendering components on the server on every request, and instead directly send the cached result to the client, resulting in faster page loads.

> **Related terms**:
>
> - You may see **Render Cache** being referred to as **ISR Cache**, this is the same concept.
> - The terms **Automatic Static Optimization**, **Static Site Generation**, or **Static Rendering** might be also be used interchangeably to refer to the process of rendering and caching parts of your application code on the server at build time.

To understand how Render Cache works, it's helpful to look at how React handles rendering, and how Next.js caches the output. Here's a high-level overview of the process:

#### 1. React Rendering on the Server

On the server, Next.js uses React's APIs to orchestrate rendering. This process is split into three stages:

1. React renders Server Components into a special data format, optimized for streaming, called the [**React Server Payload**](). This Payload contains:

- The rendered result of Server Components
- Placeholders for where Client Components should be rendered on the client
  - Any serialized props passed to these Client Components
  - References to the JavaScript instructions needed to render the Client Components
- Metadata tags, such as references to stylesheets

2. Next.js compiles, bundles, and code-splits the JavaScript instructions for rendering Client Components on the client.
3. The **React Payload** and **JavaScript instructions** are used to pre-render HTML on the server.

> To learn more about React's rendering process, the React Payload, and how it relates to Server and Client Components. Please see the [React Rendering]() documentation.

#### 2. Next.js Caching on the Server (Render Cache)

On the server and at build time, Next.js caches the React Server Payload, Client Component JavaScript, and pre-rendered HTML.

#### 3. Next.js Caching on the Client (Router Cache)

At request time, the React Server Payload, Client Component JavaScript, and pre-rendered HTML are sent to the client (browser). The React Server Payload is stored in the [Router Cache](). This is a separate in-memory client cache, split by in individual route segments.

> The [Router cache]() is used to improve the navigation experience by prefetching the payload for route segments, and reducing server requests for route segments that do not change between navigations. Learn more about the [Router Cache]().

#### 4. React Hydration and Reconciliation on the Client

Then, on the client:

1. The HTML is used to show an initial preview for Client and Server Components.
2. The React payload is used to reconcile the Client and Server Component trees.
3. The JavaScript instructions are used to [hydrate]() Client Components.

#### 5. Subsequent Navigations

On subsequent navigations or during prefetching, Next.js will check if the payload for route segments are already in the Router Cache. If so, it will skip sending a new request to the server.

If the route segments are not cached, Next.js will fetch the render output from the Render Cache on the server, and populate the Router Cache on the client.

#### Duration

By default, the Render Cache is persistent. This means that the render output is cached across user requests. In Next.js, this is called [Static Rendering]().

It's important to note invalidating the [Data Cache]() will always invalidate the Render Cache. This is because the render output depends on data. However, you can invalidate the Render Cache without invalidating the Data Cache.

#### Invalidation

There are two ways you can **invalidate** the Render Cache:

- **[Revalidating Data]():** This will invalidate the [Data Cache](), which in turn will re-render components on the server, and cache the new render output.
- **Redeploying**: Unlike the data cache, which persists across deployments, the Render Cache is cleared on new deployments.

#### Opting out

You can opt out of Static Rendering, or in other words, **skip** the Render Cache by:

- **Using a [Dynamic Function]()**: This will dynamically render components at request time, but may reuse cached data, if any.
- **Opting into [Dynamic Data Fetching]()**: This will fetch data on every request, which in turn will skip the Render Cache.
- **Using the route segment config options `dynamic = force-dynamic` or `revalidate = 0`**: This will skip the Render Cache and the Data Cache. Meaning components will be rendered and data fetched on every request.

### Router Cache

### APIs

The following table provides a high-level overview of how different APIs affect caching:

| API                                     | Router Cache | Render Cache          | Data Cache            | React Cache |
| --------------------------------------- | ------------ | --------------------- | --------------------- | ----------- |
| `<Link prefetch>`                       | Cache        |                       |                       |             |
| `router.prefetch`                       | Cache        |                       |                       |             |
| `router.refresh`                        | Revalidate   |                       |                       |             |
| `fetch`                                 |              |                       | Cache                 | Cache       |
| `fetch.options.cache`                   |              |                       | Cache or Opt-out      |             |
| `fetch.options.next.revalidate`         |              | Revalidate            | Revalidate            |             |
| `fetch.options.next.tags`               |              | Cache                 | Cache                 |             |
| `revalidatePath`                        | Revalidate   | Revalidate            | Revalidate            |             |
| `revalidateTag`                         | Revalidate   | Revalidate            | Revalidate            |             |
| `const revalidate`                      |              | Revalidate or Opt-out | Revalidate or Opt-out |             |
| `const dynamic`                         |              | Cache or Opt-out      | Cache or Opt-out      |             |
| `headers`, `cookies`, `useSearchParams` |              | Opt-out               |                       |             |
| `React.cache`                           |              |                       |                       | Cache       |
| `unstable_cache` (Experimental)         |              |                       | Coming Soon           |             |
