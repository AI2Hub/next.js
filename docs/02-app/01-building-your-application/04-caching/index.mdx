---
title: Caching in Next.js
nav_title: Caching
description: An overview of caching mechanisms in Next.js.
---

Next.js has a few caching mechanisms to improve your application's performance. This page provides an in-depth look at caching, the APIs you can use to configure them, and how they interact with each other.

## Overview

{/* TO DO: Diagram showing how caching mechanisms come into play in the request lifecycle, going from initial request, to server, to response, to router cache, to subsequent navigation with new request. */}

Here's a high-level overview of the different caching mechanisms in Next.js and their purpose:

| Mechanism                     | What is cached?                | Where is it cached? | Why is it cached?                                             | Duration                        |
| ----------------------------- | ------------------------------ | ------------------- | ------------------------------------------------------------- | ------------------------------- |
| [React Cache](#react-cache)   | Return values of functions     | Server              | Reduce data store calls and share data between route segments | Per-request lifecycle           |
| [Data Cache](#data-cache)     | Return values of data requests | Server              | Store data across user requests and deployments               | Persistent (can be revalidated) |
| [Render Cache](#render-cache) | Rendered HTML and RSC payload  | Server              | Reduce rendering cost and improve performance                 | Persistent (can be revalidated) |
| [Router Cache](#router-cache) | Route Segments (RSC Payload)   | Client              | Reduce server requests and improve navigation experience      | User session or time-based.     |

## How caching works

### React Cache

React's `cache` function allows you to **memoize** the return value of a function, saving the result to memory. In React Server Components, the [`fetch` API](#fetch) uses an implementation similar to `cache` to **memoize** data requests using the same URL and options. This means you can call the same data in multiple components while only executing it once during a render pass of a React component tree.

<Image
  alt="Fetch Request Deduplication"
  srcLight="/docs/light/deduplicated-fetch-requests.png"
  srcDark="/docs/dark/deduplicated-fetch-requests.png"
  width="1600"
  height="857"
/>

With `fetch`, you can fetch data in the components that need it without props drilling and worrying about the performance impact of making multiple requests for the same data. Memoization applies to `fetch` requests in `generateMetadata`, `generateStaticParams`, Layouts, Pages, and other Server Components

For example:

```tsx filename="app/page.tsx" switcher
async function getComments() {
  const res = await fetch('https://...') // The result is cached
  return res.json()
}

// This function is called twice, but the result is only fetched once
const comments = await getComments() // cache MISS

// The second call could be anywhere in your application
const comments = await getComments() // cache HIT
```

```jsx filename="app/page.js" switcher
async function getComments() {
  const res = await fetch('https://...') // The result is cached
  return res.json()
}

// This function is called twice, but the result is only fetched once
const comments = await getComments() // cache MISS

// The second call could be anywhere in your application
const comments = await getComments() // cache HIT
```

For cases where `fetch` is not suitable (e.g. database clients, CMS clients, or GraphQL), you can use React's `cache` function to manually memoize functions.

> **Memoization vs. Deduplication**:
>
> You may see the terms **memoization** and **deduplication** being used interchangeably. Memoization is a general term that applies storing the return values of **any function** in-memory, whereas request deduplication applies specifically to **data requests**.

#### Duration

The cache lasts the lifetime of a server request or static rendering until rendering the React tree completes.

#### Revalidating

React's `cache` function is used specifically for memoizing the return values of functions. Since the memoization is not shared across requests and only applies during the rendering of the React tree, there is no need for revalidation.

#### Opting out

To opt out of memoization in `fetch` requests, you can pass an `AbortController` `signal` to the request.

```js
const { signal } = new AbortController()
fetch(url, { signal })
```

Since you manually opt into using the `cache` function, there's no way to opt out.

### Data Cache

Next.js has a built-in Data Cache that stores the result of data requests across user requests and deployments.

By default, data requests that use `fetch` are automatically cached. This is possible because Next.js extends the native `fetch` API to allow each request on the server to set its own persistent caching semantics.

You can use the [`cache`](#fetchoptionscache) and [`next.revalidate`](#fetchoptionsnextrevalidate) options of `fetch` to configure the caching behavior. In the browser, `cache` indicates how a fetch request will interact with the browser's HTTP cache, and with Next.js, the `cache` option also indicates how a server-side fetch request will interact with the framework's Data Cache.

When fetching data on the server, a `fetch` request first checks the Data Cache for a cached response. If a cached response is found, it is returned immediately. If not, the request is made to the data source, and the response is cached.

> **Static vs. Dynamic Data Fetching**:
>
> You may see the terms **Static Data Fetching** and **Dynamic Data Fetching** being used. Static Data Fetching refers to cached data requests (default), whereas Dynamic Data Fetching refers to data that is fetched on every request, at runtime.

#### Duration

The Data Cache is persistent across user requests and deployments unless you revalidate or opt-out.

#### Revalidating

Revalidation is the process of purging the Data Cache and re-fetching the latest data. This is useful when your data changes and you want to ensure you show the latest information.

Cached data can be revalidated in two ways:

- **Time-based revalidation**: Automatically revalidate data after a certain amount of time has passed. This is useful for data that changes infrequently and freshness is not as critical. Time-based revalidation can be configured with the [Route Segment Config options](#segment-config-options) or per individual [`fetch` request](#fetchoptionsnextrevalidate).
- **On-demand revalidation**: Manually revalidate data based on an event (e.g. form submission). On-demand revalidation can use a tag-based or path-based approach to revalidate groups of data at once. This is useful for when you want to ensure the latest data is always shown. On-demand revalidation can be configured with the [`revalidateTag`](#fetchoptionsnexttag-and-revalidatetag) and [`revalidatePath`](#revalidatepath) APIs.

> **Good to know**: Check if your upstream data provider has caching enabled by default. You might need to disable (e.g. `useCdn: false`), otherwise a revalidation won't be able to pull fresh data to update the Data Cache. Caching can occur at a CDN (for an endpoint being requested) when it returns the `Cache-Control` header. ISR on Vercel [persists the cache globally and handles rollbacks](https://vercel.com/docs/concepts/incremental-static-regeneration/overview).

#### Opting out

For individual data fetches, you can opt out of caching by setting the [`cache`](#fetchoptionscache) option to `no-store`. This means data will be fetched dynamically, on each request.

```jsx
// Opt out of caching
fetch(`https://...`, { cache: 'no-store' })
```

Alternatively, you can also use the [Route Segment Config options](#segment-config-options) to opt out of caching for **all** data requests in a route segment.

> **Vercel Data Cache**
>
> If your Next.js application is deployed to Vercel, we recommend reading the [Vercel Data Cache](https://vercel.com/docs/infrastructure/data-cache) documentation for a better understanding of Vercel specific features.

### Render Cache

Next.js automatically caches the rendered result of React Components on the server at build time. This is an optimization that allows you to skip rendering components on the server on every request, and instead directly send the cached result to the client, resulting in faster page loads.

> **Related terms**:
>
> - The terms **Automatic Static Optimization**, **Static Site Generation**, or **Static Rendering** might be also be used interchangeably to refer to the process of rendering and caching parts of your application code on the server at build time.

To understand how the Render Cache works, it's helpful to look at how React handles rendering, and how Next.js caches the result:

#### 1. React Rendering on the Server

On the server, Next.js uses React's APIs to orchestrate rendering. This process is split into three stages:

1. React renders Server Components into a special data format, optimized for streaming, called the **React Server Component Payload**.
2. Next.js compiles, bundles, and code-splits the **JavaScript instructions** for rendering Client Components on the client.
3. Next.js uses the React Payload and JavaScript instructions to pre-render **HTML** on the server.

> **What is React Server Component Payload?**
>
> The React Payload is a compact string representation of the React Component tree. It's used by React on the client to update the DOM. The React Payload contains:
>
> - The rendered result of Server Components
> - Placeholders for where Client Components should be rendered on the client
> - Any serialized props passed to these Client Components
> - References to the JavaScript instructions needed to render the Client Components
> - Metadata tags, such as references to stylesheets
>
> To learn more, see the [React Rendering](/docs/app/building-your-application/rendering/react-components) documentation.

#### 2. Next.js Caching on the Server (Render Cache)

On the server, at build time, Next.js caches the React Server Component Payload, Client Component JavaScript, and pre-rendered HTML.

#### 3. Next.js Caching on the Client (Router Cache)

At request time, the React Server Component Payload is stored in the client-side [Router Cache](#router-cache) - a separate in-memory cache, split by individual routes. This Router Cache is used to improve the navigation experience by prefetching.

#### 4. React Hydration and Reconciliation on the Client

Then, on the client:

1. The HTML is used to show an initial preview for Client and Server Components.
2. The React payload is used to reconcile the Client and Server Component trees, and update the DOM.
3. The JavaScript instructions are used to [hydrate](https://react.dev/reference/react-dom/client/hydrateRoot) Client Components.

#### 5. Subsequent Navigations

On subsequent navigations or during prefetching, Next.js will check if the React Server Components Payload is stored in Router Cache. If so, it will skip sending a new request to the server.

If the route segments are not in the cache, Next.js will fetch the React Server Components Payload from the server, and populate the Router Cache on the client.

#### Duration

By default, the Render Cache is persistent. This means that the render output is cached across user requests.

#### Invalidation

There are two ways you can **invalidate** the Render Cache:

- **Revalidating Data** This will invalidate the [Data Cache](#data-cache), which in turn will re-render components on the server, and cache the new render output.
- **Redeploying**: Unlike the Data Cache, which persists across deployments, the Render Cache is cleared on new deployments.

#### Opting out

You can opt out of the Render Cache, or in other words, dynamically render components at request time, by:

- **Using a [Dynamic Function](#dynamic-functions)**: This will dynamically render components at request time, but may reuse cached data, if any.
- **Opting out of the [Data Cache](#data-cache)**: This will fetch data on every request, which in turn will skip the Render Cache.
- **Using the route segment config options `dynamic = force-dynamic` or `revalidate = 0`**: This will skip the Render Cache and the Data Cache. Meaning components will be rendered and data fetched on every request.

> **Static vs. Dynamic Rendering**:
>
> You may see the terms **Static Rendering** and **Dynamic Rendering** being used. Static Rendering refers to caching the render output on the server, at build time, whereas Dynamic Rendering refers to rendering components on every request, at runtime.

### Router Cache

Next.js has an in-memory client-side cache that stores the React Server Component Payload, split by individual routes. This **Router Cache** is used to improve the navigation experience. Next.js [prefetches](/docs/app/building-your-application/routing/linking-and-navigating#prefetching) and caches routes that the user is likely going to navigate to (when using the `<Link >` component), and caches visited route segments, enabling [partial rendering](/docs/app/building-your-application/routing/linking-and-navigating#partial-rendering). This applies to newly visited routes, as well as backward/forward browser navigation.

For the user, this results in [soft navigation](/docs/app/building-your-application/routing/linking-and-navigating#soft-navigation) (no page reloads) and faster page transitions; it also reduces unnecessary requests to the server.

> **Good to know:**
>
> You may see the Router Cache being referred to as **Client-side Cache** or **Prefetch Cache**. While **Prefetch Cache** refers to the prefetched route segments, **Client-side Cache** refers to the whole Router cache, which includes both visited and prefetched segments.
> This cache specifically applies to Next.js and Server Components, and is different to the browser's [bfcache](https://web.dev/bfcache/).

#### Duration

The cache is stored in the browser's temporary memory. Two factors determine how long the router cache lasts:

- **Session**: The cache persists across [soft navigations](/docs/app/building-your-application/routing/linking-and-navigating#soft-navigation). However, it's cleared on page refresh or [hard navigation](/docs/app/building-your-application/routing/linking-and-navigating#hard-navigation).
- **Automatic invalidation period**: The cache of an individual segment is automatically invalidated after a specific time. The duration depends on whether the route is [statically rendered](/docs/app/building-your-application/rendering/static-and-dynamic-rendering#static-rendering-default) or [dynamically rendered](/docs/app/building-your-application/rendering/static-and-dynamic-rendering#dynamic-rendering):
  - **Dynamic routes**: 30 seconds
  - **Static routes**: 5 minutes

While a page refresh or hard navigation will clear **all** cached segments, the automatic invalidation period only affects the individual segment from the time it was last accessed or created.

#### Invalidation

**[Server Actions](/docs/app/building-your-application/data-fetching/server-actions)** can be used to revalidate data on-demand by path ([`revalidatePath`](/docs/app/api-reference/functions/revalidatePath)) or by cache tag ([`revalidateTag`](/docs/app/api-reference/functions/revalidateTag)), which in turn will invalidate the Router Cache.

#### Opting out

It's not possible to opt out of the Router Cache.

You can opt out of prefetching by setting the `prefetch` prop of the `<Link>` component to `false`. However, this will still temporarily store the route segments for 30s to allow instant navigation between nested segments, such as tab bars.

The routes will still be cached when visited.

## Cache Interactions

When configuring the different caching mechanisms, it's important to understand how they interact with each other:

### Data and Render

- Invalidating or opting out of the Render Cache **does not** affect the Data Cache. This means you can dynamically render a route that has both cached and uncached data. This is useful when most of your page uses cached data (static), but you have a few components that rely on data that needs to be fetched at request time (dynamic). You can dynamically render without worrying about the performance impact of re-fetching all the data.
- Revalidating the Data Cache **will** invalidate the Render Cache, as the render output depends on data.

### Data and Router

- Revalidating the Data Cache **will not** immediately invalidate the Router Cache due to the [automatic invalidation period](#duration-and-invalidation). This means the Router Cache will continue to serve the previous payload until a hard refresh, or the automatic invalidation period has elapsed.
- To immediately invalidate the Router Cache, you can use [`revalidatePath`](#revalidatepath) or [`revalidateTag`](#fetchoptionsnexttag-and-revalidatetag) in a [Server Action](/docs/app/building-your-application/data-fetching/server-actions).

## APIs

The following table provides an overview of how different Next.js APIs affect caching:

| API                                                                 | Router Cache | Render Cache          | Data Cache            | React Cache |
| ------------------------------------------------------------------- | ------------ | --------------------- | --------------------- | ----------- |
| [`<Link prefetch>`](#link)                                          | Cache        |                       |                       |             |
| [`router.prefetch`](#routerprefetch)                                | Cache        |                       |                       |             |
| [`router.refresh`](#routerrefresh)                                  | Revalidate   |                       |                       |             |
| [`fetch`](#fetch)                                                   |              |                       | Cache                 | Cache       |
| [`fetch.options.cache`](#fetchoptionscache)                         |              |                       | Cache or Opt out      |             |
| [`fetch.options.next.revalidate`](#fetchoptionsnextrevalidate)      |              | Revalidate            | Revalidate            |             |
| [`fetch.options.next.tags`](#fetchoptionsnexttag-and-revalidatetag) |              | Cache                 | Cache                 |             |
| [`revalidateTag`](#fetchoptionsnexttag-and-revalidatetag)           |              | Revalidate            | Revalidate            |             |
| [`revalidatePath`](#revalidatepath)                                 |              | Revalidate            | Revalidate            |             |
| [`const revalidate`](#segment-config-options)                       |              | Revalidate or Opt out | Revalidate or Opt out |             |
| [`const dynamic`](#segment-config-options)                          |              | Cache or Opt out      | Cache or Opt out      |             |
| [`cookies`](#cookies)                                               | Revalidate   | Opt out               |                       |             |
| [`headers`, `useSearchParams`, `searchParams`](#dynamic-functions)  |              | Opt out               |                       |             |
| [`React.cache`](#react-cache-function)                              |              |                       |                       | Cache       |
| [`unstable_cache`](#unstable_cache) (Coming Soon)                   |              |                       |                       |             |

### `<Link>`

By default, the `<Link>` component automatically prefetches static routes (cached) and adds the React Payload to the Router Cache.

To disable prefetching, you can set the `prefetch` prop to `false`. But this will not skip the cache permanently, the route segment will still be cached client-side when the user visits the route.

Learn more about the [`<Link>` component](/docs/app/api-reference/components/link).

### `router.prefetch`

The `prefetch` option of the `useRouter` hook can be used to manually prefetch a route. This adds the React Payload to the Router cache.

See the [`useRouter` hook](/docs/app/api-reference/functions/use-router) API reference.

### `router.refresh`

The `refresh` option of the `useRouter` hook can be used to manually refresh a route. This completely clears the Router Cache, and makes a new request to the server. `refresh` does not revalidate the Data or Render Cache, it reuses the cached data and rendering result, if it exists.

The rendered result will be reconciled on the client without losing the React state or browser state (e.g. scroll position).

See the [`useRouter` hook](/docs/app/api-reference/functions/use-router) API reference.

### `fetch`

Data returned from `fetch` is automatically cached.

```jsx
// Cached by default. `force-cache` is the default option and can be ommitted.
fetch(`https://...`, { cache: 'force-cache' })
```

See the [`fetch` API Reference](/docs/app/api-reference/functions/fetch) for more options.

### `fetch.options.cache`

You can opt individual `fetch` requests out of data caching by setting the `cache` option to `no-store`:

```jsx
// Opt out of caching
fetch(`https://...`, { cache: 'no-store' })
```

Since the render output depends on data, using `cache: 'no-store'` will also skip the Render Cache for the route where the `fetch` request is used. That is, the route will be dynamically rendered, but you can still have other cached data requests in the same route.

See the [`fetch` API Reference](/docs/app/api-reference/functions/fetch) for more options.

### `fetch.options.next.revalidate`

You can use the `next.revalidate` option of `fetch` to set the revalidation period (in seconds) of an individual `fetch` request. This will revalidate the Data Cache, which in turn will invalidate the Render Cache. Fresh data will be fetched, and components will be re-rendered on the server.

```jsx
// Revalidate after 1 hour
fetch(`https://...`, { next: { revalidate: 3600 } })
```

See the [`fetch` API reference](/docs/app/api-reference/functions/fetch) for more options.

### `fetch.options.next.tag` and `revalidateTag`

Next.js has a cache tagging system for fine-grained data caching and revalidation.

1. When using `fetch` and `unstable_cache`, you have the option to tag cache entries with one or more tags.
2. Then, you can call `revalidateTag` to revalidate all entries associated with that tag.

For example, you can set a tag when fetching data:

```jsx
// Cache data with a tag
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

Then, then call `revalidateTag` with a tag to revalidate:

```jsx
// Revalidate entries with a specific tag
revalidateTag('a')
```

There are two places you can use `revalidateTag`, depending on what you're trying to achieve:

1. [Route Handlers](/docs/app/building-your-application/routing/router-handlers) - to revalidate data in response of a third party event (e.g. webhook).
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions) - to revalidate data after a user action (e.g. form submission).

{/_ TO DO: Talk about how revalidateTag affects other caches and re-rendering.
If you're calling it from a route handler, then it makes sense if it's for next UI visit, but for server actions, the user would expect a visual update / rerender _/}

### `revalidatePath`

`revalidatePath` allows you manually revalidate data **and** re-render the route segments below a specific path in a single operation. Calling `revalidatePath` methods revalidate the Data Cache, which in turn invalidates the Render Cache. It does not immediately invalidate the Router Cache due to the [automatic invalidation period](#duration-and-invalidation).

```jsx
revalidatePath('/')
```

There are two places you can use `revalidatePath`, depending on what you're trying to achieve:

1. [Route Handlers](/docs/app/building-your-application/routing/router-handlers) - to revalidate data in response of a third party event (e.g. webhook).
2. [Server Actions](/docs/app/building-your-application/data-fetching/server-actions) - to revalidate data after a user action (e.g. form submission).

> ** `revalidatePath` vs. `router.refresh`**:
>
> Calling `router.refresh` will clear the Router cache, and re-render route segments on the server without invalidating the Data Cache or the Render Cache.
>
> The difference is that `revalidatePath` **revalidates** cached data in Static Routes, whereas `router.refresh` **reuses** cached data.

See the [`revalidatePath` API reference]() for more information.

> **Differences between `res.revalidate` vs. `revalidateTag` / `revalidatePath`**:
>
> There are a couple of differences between `res.revalidate` and `revalidateTag` / `revalidatePath`:
>
> 1. `res.revalidate` was built for API Routes in the Pages Router, when rendering and data fetching were coupled together in the same cache.
> 2. `res.revalidate` applies specifically to the Render Cache, and not the Data Cache or Router Cache.
> 3. `res.revalidate` returns a promise, whereas `revalidateTag` and `revalidatePath` are non-blocking, _fire-and-forget_ APIs.

### Dynamic Functions

`cookies`, `headers`, `useSearchParams`, and `searchParams` are all dynamic functions that depend on runtime information. Using them will opt a route out of the Render Cache, in other words, the routes will be dynamically rendered.

#### `cookies`

Using `cookies.set` or `cookies.delete` in a Server Action invalidates the Router Cache to prevent routes that use cookies from becoming stale (e.g. authentication).

See the [`cookies`](/docs/app/api-reference/functions/cookies) API reference.

### Segment Config Options

The Route Segment Config options can be used configure the caching behavior of _all_ fetch requests in a route segment. Although you can configure individual fetch requests, for multiple fetch requests, it's generally recommended to configure the cache and time-based revalidation at the route segment level - this prevents unexpected scenarios where `fetch` requests in the same segment revalidate at different times.

The following Route Segment Config options will opt out of the Data and Render Cache:

- `const dynamic = force-dynamic`
- `const revalidate = 0`

See the [Route Segment Config](/docs/app/api-reference/file-conventions/route-segment-config) documentation for more options.

### React `cache` function

The React `cache` function allows you to memoize the return value of a function, allowing you to call the same function multiple times while only executing it once.

Next.js uses `cache` to deduplicate data requests when using `fetch`. But you can also use `cache` to manually deduplicate data requests for use cases when the `fetch` API is not suitable. For example, database clients, CMS clients, or GraphQL.

```tsx filename="utils/get-user.ts" switcher
import { cache } from 'react'

export const getUser = cache(async (id: string) => {
  const user = await db.user.findUnique({ id })
  return user
})
```

```jsx filename="utils/get-user.js" switcher
import { cache } from 'react'

export const getUser = cache(async (id) => {
  const user = await db.user.findUnique({ id })
  return user
})
```

### `unstable_cache`

`unstable_cache` is an experimental API for adding values to the Data Cache when the `fetch` API is not suitable. For example, when using database clients, CMS clients, or GraphQL.

```jsx
import { unstable_cache } from 'next/cache'

export default async function Page() {
  const cachedData = await unstable_cache(
    async () => {
      const data = await db.query('...')
      return data
    },
    ['cache-key'],
    {
      tags: ['a', 'b', 'c'],
      revalidate: 10,
    }
  )()
}
```

> **Warning**: This API is being developed, and we do not recommend using it in production. It's listed here to show the direction for the Data Cache.
