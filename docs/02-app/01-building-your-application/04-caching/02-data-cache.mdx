---
title: Data Cache
description: Learn about the Next.js server-side persistent data cache, and how to configure the caching and revalidation behavior.
---

Next.js has a built-in data caching mechanism that stores the result of data requests across user requests and deployments. This lowers cost and improves performance by reducing the number of requests to your data source.

## How it works

Next.js extends the native [Web fetch() API]() to allow each request on the server to set its own persistent caching semantics. By default, data requests that use `fetch` are automatically cached, and you can use the [`cache`]() and [`next.revalidate`]() options of `fetch` to configure the caching behavior.

When fetching data on the server, a `fetch` request first checks the persistent HTTP cache for a cached response. If a cached response is found, it is returned immediately. If not, the request is made to the data source, and the response is cached.

> **Good to know:**
>
> In the browser, the `cache` option indicates how a fetch request will interact with the browser's HTTP cache. By extending the `fetch` API, you can use `cache` to indicate how a server-side fetch request will interact with the framework's persistent HTTP cache.

## Duration and Invalidation

The cache is persistent across user requests and deployments, unless you revalidate or opt out of caching.

### Revalidation

Revalidation is the process of purging the cache and re-fetching the latest data. This is useful when your data changes and you want to ensure you show the latest information.

Cached data can be revalidated in two ways:

- **Time-based revalidation**: Automatically revalidate data after a certain amount of time has passed. This is useful for data that changes infrequently and freshness is not as critical. Time-based revalidation can be configured with the [Route Segment Config options]() or per invididual [`fetch` request]().
- **On-demand revalidation**: Manually revalidate data based on an event (e.g. form submission). On-demand revalidation can use a tag based or path based approach to revalidate groups of data at once. This is useful for when you want to ensure the latest data is shown. On-demand revalidation can be configured with the [`revalidateTag`]() and [`revalidatePath`]() APIs.

> **Vercel Data Cache**
>
> If your Next.js application is deployed to Vercel, we recommend reading the [Vercel Data Cache](https://vercel.com/docs/infrastructure/data-cache) documentation for a better understanding of Vercel specific features.

### Opting out of caching

You can configure the cache option to completely out of data caching, and fetch data on every request, this is called [Dynamic Data Fetching]().

> **Differences between Dynamic Fetching vs. Dynamic Rendering**:
>
> You may see the term **Dynamic Rendering** being used, this is different to Dynamic Data Fetching. In the App Router, data fetching and rendering are not coupled together. So you have the option to use Dynamic Rendering with some cached data. See [Interactions]() for more information.

## APIs

The following APIs affect the Data Cache:

### `fetch.cache`

`fetch` requests are cached automatically. But you can opt individual `fetch` requests out of caching by setting the `cache` option to `no-store`:

```jsx
// Cached by default. `force-cache` is the default option and can be ommitted.
fetch(`https://...`, { cache: 'force-cache' })
```

```jsx
// Opt out of caching
fetch(`https://...`, { cache: 'no-store' })
```

See the [`fetch` API reference]() for more options.

### `fetch.next.revalidate`

You can use the `next.revalidate` option of `fetch` to set the revalidation period (in seconds) of an individual `fetch` request.

```jsx
// Revalidate after 1 hour
fetch(`https://...`, { next: { revalidate: 3600 } })
```

See the [`fetch` API reference]() for more options.

### Route Segment Config

The Route Segment Config options can be used configure the caching behavior of _all_ fetch requests in a route segment (e.g. layout or page). Although you can configure individual fetch requests, for multiple fetch requests, it's generally recommended to configure the cache and time-based revalidation at the route segment level - this prevents unexpected scenarios where requests in the same segment revalidate at different times.

```tsx filename="layout.tsx / page.tsx" switcher
export const revalidate = 3600

export default async function Segment() {
  const data = await fetch(`https://...`)
}
```

```jsx filename="layout.js / page.js" switcher
export const revalidate = 3600

export default async function Segment() {
  const data = await fetch(`https://...`)
}
```

See the [Route Segment Config API reference]() for all options.

See the [`useRouter` hook]() API reference.

### `revalidatePath`

`revalidatePath` allows you manually revalidate data **and** re-render the route segments of a specific path in a single operation. Calling `revalidatePath` invalidates the Data Cache and [Render Cache]() on the server, and [Router Cache]() on the client.

There are two places you can use `revalidatePath`, depending on what you're trying to achieve:

1. [Route Handlers]() - usually to revalidate data in response of a third party event (e.g. webhook).
2. [Server Actions]() - usually to revalidate data after a user action (e.g. form submission).

```jsx
revalidatePath('/')
```

> ** `revalidatePath` vs. `router.refresh`**:
>
> Calling `router.refresh` will clear the Router cache, and re-render route segments on the server without invalidating the Data Cache or the Render Cache.
>
> `revalidatePath` is better suited if you need to invalidate the Data Cache **and** Router Cache for a specific path.

See the [`revalidatePath` API reference]() for more information.

### `revalidateTag`

Next.js has a cache tagging system for fine-grained cache storage and revalidation.

1. When using `fetch` and `unstable_cache`, you have the option to tag cache entries with one or more tags.
2. Then, you can call `revalidateTag` to revalidate all entries associated with that tag.

For example, you can set a tag when fetching data:

```jsx
// Cache data with a tag
fetch(`https://...`, { next: { tags: ['a', 'b', 'c'] } })
```

Then, then call `revalidateTag` with a tag to revalidate:

```jsx
// Revalidate entries with a specific tag
revalidateTag('a')
```

There are two places you can use `revalidateTag`, depending on what you're trying to achieve:

1. [Route Handlers]() - usually to revalidate data in response of a third party event (e.g. webhook).
2. [Server Actions]() - usually to revalidate data after a user action (e.g. form submission).

{/_ TO DO: Talk about how revalidateTag affects other caches and re-rendering.
If you're calling it from a route handler, then it makes sense if it's for next UI visit, but for server actions, the user would expect a visual update / rerender _/}

> **Differences between `res.revalidate` vs. `revalidateTag` / `revalidatePath`**:
>
> There are a couple of differences between `res.revalidate` and `revalidateTag` / `revalidatePath`:
>
> 1. `res.revalidate` was built for API Routes in the Pages Router, when rendering and data fetching were coupled together in the same cache.
> 2. `res.revalidate` applies specifically to the Render Cache (ISR), and not the Data Cache or Router Cache.
> 3. `res.revalidate` returns a promise, whereas `revalidateTag` and `revalidatePath` are non-blocking, _fire-and-forget_ APIs.

### `unstable_cache`

`unstable_cache` is an experimental API for adding values to the Data Cache when the `fetch` API is not suitable. For example, database clients, CMS clients, or GraphQL.

```jsx
import { unstable_cache } from 'next/cache'

export default async function Page() {
  const cachedData = await unstable_cache(
    async () => {
      const data = await db.query('...')
      return data
    },
    ['cache-key'],
    {
      tags: ['a', 'b', 'c'],
      revalidate: 10,
    }
  )()
}
```

> **Warning**: This API is being developed, and we do not recommend using it in production. It's listed here to show the direction for the Data Cache.
